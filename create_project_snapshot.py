#!/usr/bin/env python3
"""Снимок репозитория: дерево проекта + содержимое ТОЛЬКО файлов с разрешёнными
расширениями: py,json,html,css,yml,yaml,docker,md,txt,sql. Вывод делится на части.
"""

from __future__ import annotations

import argparse
import math
import os
from pathlib import Path
from typing import Iterable, List

DEFAULT_PARTS = 10

# Папки и файлы, которые исключаем из дерева и обхода.
EXCLUDED_DIR_NAMES = {
    ".git",
    "__pycache__",
    ".mypy_cache",
    ".pytest_cache",
    "node_modules",
    "snapshot_parts",
}
EXCLUDED_FILE_NAMES = {".DS_Store"}

# Разрешённые расширения (без точки).
ALLOWED_SUFFIXES = {
    "py", "json", "html", "css", "yml", "yaml", "docker", "md", "txt", "sql",
}


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Сделать снимок репозитория: дерево проекта и содержимое файлов "
            "с выбранными расширениями, разрезанное на несколько текстовых частей."
        )
    )
    parser.add_argument(
        "--parts",
        type=int,
        default=DEFAULT_PARTS,
        help="Сколько частей сделать (по умолчанию: %(default)s)",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path("snapshot_parts"),
        help="Куда писать части (создастся при необходимости).",
    )
    parser.add_argument(
        "--root",
        type=Path,
        default=Path.cwd(),
        help="Корень проекта (по умолчанию: текущая директория).",
    )
    return parser.parse_args()


def iter_project_files(root: Path) -> Iterable[Path]:
    """Обойти файлы проекта и вернуть только разрешённые по расширению."""
    for path in sorted(root.rglob("*")):
        if path.is_dir():
            continue
        if any(part in EXCLUDED_DIR_NAMES for part in path.parts):
            continue
        if path.name in EXCLUDED_FILE_NAMES:
            continue
        suffix = path.suffix.lower().lstrip(".")
        if suffix in ALLOWED_SUFFIXES:
            yield path


def build_tree(root: Path) -> str:
    """Построить ASCII-дерево проекта (с исключениями папок/файлов)."""
    lines: List[str] = []

    for dirpath, dirnames, filenames in os.walk(root):
        rel_dir = Path(dirpath).relative_to(root)
        depth = len(rel_dir.parts)
        indent = "    " * depth

        if depth == 0:
            lines.append(".")
        else:
            lines.append(f"{indent}{rel_dir.name}")

        # Фильтруем папки in-place
        dirnames[:] = sorted(
            d for d in dirnames
            if d not in EXCLUDED_DIR_NAMES
            and not (Path(dirpath, d).name in EXCLUDED_DIR_NAMES)
        )

        # Фильтруем выводимые имена файлов только по исключениям (дерево — полное)
        for filename in sorted(filenames):
            if filename in EXCLUDED_FILE_NAMES:
                continue
            if any(part in EXCLUDED_DIR_NAMES for part in (Path(dirpath) / filename).parts):
                continue
            lines.append(f"{indent}    {filename}")

    return "\n".join(lines)


def read_file(path: Path) -> str:
    try:
        return path.read_text(encoding="utf-8")
    except UnicodeDecodeError:
        return path.read_bytes().decode("utf-8", errors="replace")


def build_file_sections(root: Path) -> str:
    """Секции содержимого только разрешённых файлов."""
    sections: List[str] = []
    for file_path in iter_project_files(root):
        relative_path = file_path.relative_to(root)
        sections.append(f"\n# File: {relative_path}\n")
        sections.append("```\n")
        sections.append(read_file(file_path))
        if not sections[-1].endswith("\n"):
            sections.append("\n")
        sections.append("```\n")
    return "".join(sections)


def split_content(content: str, parts: int) -> List[str]:
    if parts <= 0:
        raise ValueError("Number of parts must be positive")
    part_size = math.ceil(len(content) / parts)
    return [content[i:i + part_size] for i in range(0, len(content), part_size)]


def write_parts(chunks: List[str], output_dir: Path) -> None:
    output_dir.mkdir(parents=True, exist_ok=True)
    for index, chunk in enumerate(chunks, start=1):
        output_file = output_dir / f"project_snapshot_part_{index:02}.txt"
        header = (
            f"Snapshot part {index} of {len(chunks)}\n"
            f"Generated by create_project_snapshot.py\n"
            + "=" * 40 + "\n\n"
        )
        output_file.write_text(header + chunk, encoding="utf-8")


def main() -> None:
    args = parse_args()
    root = args.root.resolve()
    tree = build_tree(root)
    file_sections = build_file_sections(root)
    combined_content = "# Project Tree\n" + tree + "\n\n# Files\n" + file_sections
    chunks = split_content(combined_content, args.parts)
    write_parts(chunks, args.output_dir)
    print(f"Snapshot created with {len(chunks)} part(s) in '{args.output_dir}'.")


if __name__ == "__main__":
    main()