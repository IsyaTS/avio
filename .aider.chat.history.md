
# aider chat started at 2025-10-30 01:18:03

> You can skip this check with --no-gitignore  
> Add .aider* to .gitignore (recommended)? (Y)es/(N)o [Yes]: y  
> Added .aider* to .gitignore  
> /opt/avio/.venv/bin/aider  
> Using gpt-4o model with API key from environment.  
> Aider v0.86.1  
> Main model: gpt-4o with diff edit format  
> Weak model: gpt-4o-mini  
> Git repo: .git with 189 files  
> Repo-map: using 4096 tokens, auto refresh  
> https://aider.chat/HISTORY.html#release-notes  
> Would you like to see what's new in this version? (Y)es/(N)o [Yes]: y  

#### /map  
> Initial repo scan can be slow in larger repos, but only happens once.  
> Here are summaries of some files present in my git repository.
Do not propose changes to these files, treat them as *read-only*.
If you need to edit any of these files, ask me to *add them to the chat* first.

app/brain/planner.py:
⋮
│class PlannerError(RuntimeError):
⋮
│@dataclass
│class GeneratedPlan:
│    """Structured representation of the strategy for the next reply."""
│
⋮
│    def as_instruction(self) -> str:
⋮
│async def generate_sales_reply(
│    messages: Sequence[Dict[str, str]],
│    *,
│    openai_module: Any,
│    model: str,
│    timeout: float,
│    persona_language: Optional[str] = None,
⋮

app/brain/quality.py:
⋮
│class PersonaHintsProtocol(Protocol):
│    cta: str
│
│    def wants_friendly(self) -> bool:
⋮
│@dataclass
│class EnforcementContext:
│    """Context required to align reply with the generated plan."""
│
⋮
│    def fingerprint_used(self, fingerprint: str) -> bool:
⋮
│    def register_fingerprint(self, fingerprint: str, question: str | None = None) -> None:
⋮
│def question_fingerprint(question: str) -> str:
⋮
│def enforce_plan_alignment(
│    reply: str,
│    plan: GeneratedPlan,
│    persona_hints: Optional[PersonaHintsProtocol] = None,
│    *,
│    context: Optional[EnforcementContext] = None,
⋮

app/catalog/indexer.py:
⋮
│@dataclass
│class CatalogIndex:
⋮
│def ensure_catalog_index(tenant: Optional[int], items: Sequence[Dict[str, Any]]) -> Optional[Catalo
⋮

app/catalog/pipeline.py:
⋮
│@dataclass
│class PipelineReport:
⋮
│def title_contains_forbidden(text: str) -> bool:
⋮

app/catalog/retriever.py:
⋮
│def retrieve_context(
│    *,
│    items: Sequence[Dict[str, Any]],
│    needs: Optional[Dict[str, Any]] = None,
│    query: str | None = None,
│    tenant: Optional[int] = None,
│    limit: int = 5,
⋮

app/catalog_index.py:
⋮
│class CatalogIndexError(RuntimeError):
⋮
│@dataclass(frozen=True)
│class CatalogIndex:
⋮
│def build_pdf_index(
│    source: Path,
│    *,
│    output_dir: Path,
│    source_relpath: str,
│    original_name: str | None = None,
│    chunk_chars: int = 700,
│    overlap: int = 120,
⋮
│def index_to_catalog_items(index: CatalogIndex) -> List[Dict[str, Any]]:
⋮

app/common.py:
⋮
│@dataclass(frozen=True)
│class OutboxWhitelist:
⋮
│def normalize_username(value: str | None) -> str | None:
⋮
│def whitelist_contains_number(whitelist: OutboxWhitelist, digits: str) -> bool:
⋮

app/core/__init__.py:
⋮
│def tenant_config(tenant: int) -> Dict[str, Any]:
⋮
│@dataclass
│class SalesState:
│    tenant: int
⋮
│    @classmethod
│    def from_dict(cls, payload: dict) -> "SalesState":
⋮
│    def append_history(self, role: str, content: str) -> None:
⋮
│    def mark_spin_stage(self, stage: str, status: str) -> None:
⋮
│@dataclass
│class PersonaHints:
│    greeting: str = ""
⋮
│    def wants_short(self) -> bool:
⋮
│    def wants_friendly(self) -> bool:
⋮
│def extract_persona_hints(persona: str) -> PersonaHints:
⋮
│def load_persona_hints(tenant: int | None = None) -> PersonaHints:
⋮
│def load_sales_state(tenant: int | None, contact_id: int | None) -> SalesState:
⋮
│def save_sales_state(state: SalesState) -> None:
⋮
│def reset_sales_state(tenant: int | None, contact_id: int | None) -> None:
⋮
│def tenant_dir(tenant: int) -> pathlib.Path:
⋮
│def ensure_tenant_files(tenant: int) -> pathlib.Path:
⋮
│def read_tenant_config(tenant: int) -> dict:
⋮
│def write_tenant_config(tenant: int, cfg: dict) -> None:
⋮
│def read_persona(tenant: int) -> str:
⋮
│def write_persona(tenant: int, text: str) -> None:
⋮
│def load_tenant(tenant: int) -> dict:
⋮
│def load_persona(tenant: int | None = None, channel: str | None = None) -> str:
⋮
│def load_persona_structured(tenant: int | None = None) -> Dict[str, Any]:
⋮
│def persona_meta_config(tenant: int | None = None) -> Dict[str, Any]:
⋮
│def persona_catalog_csv(tenant: int) -> Optional[pathlib.Path]:
⋮
│def infer_user_needs(text: str) -> Dict[str, Any]:
⋮
│def search_catalog(
│    needs: Dict[str, Any],
│    limit: int = 5,
│    tenant: int | None = None,
│    query: str | None = None,
⋮
│def format_items_for_prompt(items: List[Dict[str, Any]], currency: str = "₽") -> str:
⋮
│def pick_cta(contact_id: int, channel: str | None, stage: str = "intro") -> Dict[str, str]:
⋮
│class SalesConversationEngine:
│    def __init__(
│        self,
│        state: SalesState,
│        branding: Dict[str, str],
│        tenant_cfg: Dict[str, Any],
│        channel_name: str,
│        persona_hints: Optional[PersonaHints] = None,
⋮
│    def observe_user(self, text: str) -> None:
⋮
│    def register_recommendations(self, items: List[Dict[str, Any]]) -> None:
⋮
│    def pending_question(self) -> Optional[str]:
⋮
│    def summary_for_llm(self) -> str:
⋮
│def observe_user_message(
│    contact_id: int,
│    tenant: int | None,
│    channel: str | None,
│    text: str,
│    tenant_cfg: Optional[dict] = None,
│    branding: Optional[Dict[str, str]] = None,
│    persona_hints: Optional[PersonaHints] = None,
⋮
│def record_bot_reply(
│    contact_id: int,
│    tenant: int | None,
│    channel: str | None,
│    reply: str,
│    tenant_cfg: Optional[dict] = None,
│    branding: Optional[Dict[str, str]] = None,
⋮
│def make_rule_based_reply(
│    last_user_text: str,
│    channel: str | None,
│    contact_id: int,
│    tenant: int | None = None,
⋮

app/dao/leads.py:
⋮
│async def get_or_create_by_peer(
│    tenant_id: int,
│    channel: str,
│    peer: str,
│    *,
│    lead_id_hint: Optional[int] = None,
│    source_real_id: Optional[int] = None,
│    title: Optional[str] = None,
│    contact: Optional[str] = None,
⋮

app/db.py:
⋮
│class DatabaseUnavailableError(RuntimeError):
⋮
│async def find_lead_by_peer(
│    tenant_id: Optional[int],
│    channel: str,
│    peer: str,
⋮
│async def upsert_lead(
│    lead_id: Optional[int],
│    channel: str = "avito",
│    source_real_id: Optional[int] = None,
│    tenant_id: Optional[int] = None,
│    telegram_user_id: Optional[int] = None,
│    telegram_username: Optional[str] = None,
│    *,
│    peer_id: Optional[int] = None,
│    peer: Optional[str] = None,
⋮
│async def stream_whatsapp_dialogs(
│    tenant_val: int,
│    since_ts: Optional[float],
│    until_ts: Optional[float],
│    limit_dialogs: Optional[int],
│    channel: str = "whatsapp",
│    per_message_limit: Optional[int] = None,
│    batch_size_dialogs: int = 200,
│    message_batch_size: int = 1000,
⋮

app/fastapi_ext/__init__.py:
⋮
│class HTTPException(Exception):
│    """Exception carrying an HTTP status code."""
│
│    def __init__(self, status_code: int = 400, detail: Any = None) -> None:
⋮
│class BackgroundTasks:
│    """Very small BackgroundTasks replacement used in tests."""
│
│    def __init__(self) -> None:
⋮
│    async def run(self) -> None:
⋮
│class UploadFile:
│    """Simple in-memory UploadFile replacement."""
│
│    def __init__(
│        self,
│        filename: str | None = None,
│        content: bytes | None = None,
│        content_type: str | None = None,
⋮
│    async def read(self) -> bytes:
⋮
│class _HeaderMap(dict):
│    def __init__(self, data: Dict[str, Any]):
│        super().__init__()
│        for key, value in data.items():
⋮
│    def get(self, key: str, default: Any = None) -> Any:  # type: ignore[override]
⋮
│class _QueryParams:
│    def __init__(self, data: Dict[str, Any]) -> None:
⋮
│    def get(self, key: str, default: Any = None) -> Any:
⋮
│    def items(self):
⋮
│    def keys(self):
⋮
│class _URL:
│    def __init__(self, base: str, path: str, query: str = "") -> None:
│        self._base = base.rstrip("/")
│        self.path = path
⋮
│class Request:
│    def __init__(
│        self,
│        *,
│        app: "FastAPI",
│        method: str,
│        path: str,
│        query_params: Dict[str, Any],
│        headers: Dict[str, Any],
│        cookies: Dict[str, Any],
│        body: bytes,
⋮
│    async def json(self) -> Any:
⋮
│class APIRouter:
│    def __init__(self, *, prefix: str = "") -> None:
│        self.prefix = prefix.rstrip("/")
⋮
│    def add_api_route(
│        self,
│        path: str,
│        endpoint: Callable[..., Any],
│        *,
│        methods: Iterable[str],
│        name: Optional[str] = None,
⋮
│    def get(self, path: str, *, name: Optional[str] = None) -> Callable[[Callable[..., Any]], Calla
⋮
│    def post(self, path: str, *, name: Optional[str] = None) -> Callable[[Callable[..., Any]], Call
⋮
│    def include_router(self, router: "APIRouter", *, prefix: str = "") -> None:
⋮
│class FastAPI:
│    def __init__(self, *, title: str | None = None) -> None:
│        self.title = title or "FastAPI"
│        self.router = APIRouter()
│        self._middlewares: List[Callable[[Request, Callable[[Request], Awaitable[Any]]], Awaitable[
│        self._mounts: Dict[str, Tuple[str, Any]] = {}
⋮
│    def add_api_route(self, path: str, endpoint: Callable[..., Any], *, methods: Iterable[str], nam
⋮
│    def get(self, path: str, *, name: Optional[str] = None) -> Callable[[Callable[..., Any]], Calla
⋮
│    def post(self, path: str, *, name: Optional[str] = None) -> Callable[[Callable[..., Any]], Call
⋮
│    def include_router(self, router: APIRouter, *, prefix: str = "") -> None:
⋮
│    def url_path_for(self, name: str, **params: Any) -> str:
⋮
│def _coerce_response(result: Any) -> Response:
⋮

app/fastapi_ext/staticfiles.py:
⋮
│class StaticFiles:
│    def __init__(self, *, directory: str, html: bool = False) -> None:
│        self.directory = Path(directory).resolve()
⋮
│    def get_response(self, path: str, method: str = "GET") -> Response:
⋮

app/fastapi_ext/templating.py:
⋮
│class Jinja2Templates:
│    def __init__(self, *, directory: str) -> None:
│        self.directory = Path(directory)
│        self.env = Environment(
│            loader=FileSystemLoader(str(self.directory)),
│            autoescape=select_autoescape(["html", "xml"]),
⋮

app/fastapi_ext/testclient.py:
⋮
│class _ClientResponse:
│    def __init__(self, response: Response) -> None:
│        self._response = response
│        self.status_code = response.status_code
│        self.headers = response.headers
⋮
│    def json(self) -> Any:
⋮
│class TestClient:
│    def __init__(self, app: FastAPI, *, base_url: str = "http://testserver") -> None:
│        self.app = app
│        self.base_url = base_url.rstrip("/")
⋮
│    def close(self) -> None:
⋮
│    def get(
│        self,
│        url: str,
│        *,
│        params: Optional[Mapping[str, Any]] = None,
│        headers: Optional[Mapping[str, Any]] = None,
│        follow_redirects: bool = True,
⋮
│    def post(
│        self,
│        url: str,
│        *,
│        params: Optional[Mapping[str, Any]] = None,
│        headers: Optional[Mapping[str, Any]] = None,
│        json: Any = None,
│        data: Any = None,
│        files: Optional[Mapping[str, Tuple[str, Any, Optional[str]]]] = None,
│        follow_redirects: bool = True,
⋮
│    def request(
│        self,
│        method: str,
│        url: str,
│        *,
│        params: Optional[Mapping[str, Any]] = None,
│        headers: Optional[Mapping[str, Any]] = None,
│        json: Any = None,
│        data: Any = None,
│        files: Optional[Mapping[str, Tuple[str, Any, Optional[str]]]] = None,
⋮
│def _coerce_response(result: Any) -> Response:
⋮

app/httpx/__init__.py:
⋮
│DEFAULT_TIMEOUT = _httpx.Timeout(connect=2.0, read=10.0, write=10.0, pool=10.0)
│DEFAULT_RETRIES = 2
│
⋮
│class _PatchedAsyncClient(_httpx.AsyncClient):
│    def __init__(self, *args, timeout: _httpx.Timeout | float | None = None, transport: _httpx.Asyn
│        if timeout is None:
│            timeout = DEFAULT_TIMEOUT
│        if transport is None and DEFAULT_RETRIES > 0:
│            transport = _httpx.AsyncHTTPTransport(retries=DEFAULT_RETRIES)
⋮
│AsyncClient = _PatchedAsyncClient
│Timeout = _httpx.Timeout
│Response = _httpx.Response
│HTTPError = _httpx.HTTPError
│HTTPStatusError = _httpx.HTTPStatusError
│RequestError = _httpx.RequestError
│TimeoutException = _httpx.TimeoutException
│
⋮

app/main.py:
⋮
│try:  # рабочие БД-хелперы; при отсутствии БД заменяются заглушками
⋮
│except ImportError:  # pragma: no cover - фоллбек для окружений без БД
│    db_module = None  # type: ignore[assignment]
│
⋮
│    async def upsert_lead(*_: object, **__: object) -> None:  # type: ignore[override]
⋮

app/models/provider_token.py:
⋮
│@dataclass(slots=True)
│class ProviderToken:
⋮

app/providers/telegram_bot.py:
⋮
│async def send_message(
│    *,
│    tenant_id: int,
│    telegram_user_id: int,
│    text: str,
⋮

app/schemas/transport.py:
⋮
│class Attachment(_AliasModel):
⋮
│class _TransportMessageBase(_AliasModel):
│    channel: str = Field(..., pattern=r"^(telegram|whatsapp)$")
⋮
│    @classmethod
│    def _ensure_tenant(cls, values: dict[str, Any]) -> dict[str, Any]:
⋮
│class MessageIn(BaseModel):
⋮

app/sklearn/feature_extraction/text.py:
⋮
│class TfidfVectorizer:
│    """Small subset of sklearn's TF-IDF vectorizer.
│
│    It implements just enough for the project's catalog retrieval tests and
│    intentionally skips rarely used advanced options.
⋮
│    def __init__(
│        self,
│        *,
│        analyzer: str = "word",
│        ngram_range: tuple[int, int] = (1, 1),
│        min_df: int = 1,
⋮
│    def fit_transform(self, raw_documents: Sequence[str]) -> _Matrix:
⋮

app/sklearn/metrics/pairwise.py:
⋮
│def linear_kernel(matrix_a, matrix_b) -> List[List[float]]:
⋮

app/starlette_ext/__init__.py:
⋮
│def register_transport_validation(app: FastAPI) -> None:
│    """Attach consistent handlers for transport validation errors."""
│
│    @app.exception_handler(RequestValidationError)
│    async def _request_validation_handler(request, exc):  # type: ignore[unused-ignore]
⋮
│    @app.exception_handler(ValidationError)
│    async def _pydantic_validation_handler(request, exc):  # type: ignore[unused-ignore]
⋮

app/starlette_ext/requests.py:
⋮
│class Request(_FastAPIRequest):
│    def __init__(self, scope: Dict[str, Any], receive) -> None:
│        app = scope.get("app")
│        method = scope.get("method", "GET")
│        path = scope.get("path", "/")
│        raw_query = scope.get("query_string", b"")
│        if isinstance(raw_query, bytes):
│            query_params = dict(parse_qsl(raw_query.decode("utf-8")))
│        else:
│            query_params = dict(parse_qsl(str(raw_query)))
│        headers = _decode_headers(scope.get("headers", []))
⋮

app/static/js/admin-dashboard.js:
⋮
│  function setMessage(text, variant = 'muted', allowHTML = false) {
│    if (!messageBox) return;
│    messageBox.className = `status-text ${variant}`.trim();
│    if (allowHTML) {
│      messageBox.innerHTML = text || '';
│    } else {
│      messageBox.textContent = text || '';
│    }
⋮

app/static/js/connect-tg.js:
⋮
│  function init(rawConfig) {
│    const providedConfig = rawConfig && typeof rawConfig === 'object' ? rawConfig : {};
│    const globalConfig =
│      window.__tgConnectConfig && typeof window.__tgConnectConfig === 'object'
│        ? window.__tgConnectConfig
│        : {};
│    const config = { ...providedConfig, ...globalConfig };
│    const tenantValue = globalConfig.tenant !== undefined ? globalConfig.tenant : config.tenant;
│    const urls = config.urls && typeof config.urls === 'object' ? config.urls : {};
│    const urlPublicKeyValue = urls.public_key !== undefined ? urls.public_key : urls.publicKey;
⋮
│    function setStatus(text, variant) {
│      if (!statusEl) {
│        return;
│      }
│      const classes = ['status-text'];
│      if (variant === 'success') {
│        classes.push('success');
│      } else if (variant === 'alert') {
│        classes.push('alert');
│      } else {
⋮

app/tests/conftest.py:
⋮
│try:
⋮
│except ModuleNotFoundError:  # pragma: no cover - optional dependency
│    class CollectorRegistry:  # type: ignore[misc]
│        def __init__(self) -> None:
⋮
│    class _DummyModule:
⋮

app/tests/test_brain_planner.py:
⋮
│class _StubResponse:
│    def __init__(self, content: str):
⋮

app/tests/test_export_artifacts.py:
⋮
│def test_no_dialog_text_fixtures_outside_tests():
⋮

app/tests/test_main_webhook.py:
⋮
│def _install_fastapi_stub() -> None:
│    if "fastapi" in sys.modules:
⋮
│    class FakeRouter:
│        def __init__(self, *_, **__):
⋮
│        def post(self, *_a, **_k):
⋮
│        def get(self, *_a, **_k):
⋮
│        def include_router(self, *_a, **_k):
⋮
│    class FakeHTTPException(Exception):
│        def __init__(self, status_code: int = 400, detail: str | None = None):
│            super().__init__(detail)
│            self.status_code = status_code
⋮
│    class FakeJSONResponse:
│        def __init__(self, data: dict, status_code: int = 200):
│            self.body = data
⋮
│    class FakeRedirectResponse(FakeJSONResponse):
│        def __init__(self, url: str, status_code: int = 303):
│            super().__init__({"url": url}, status_code)
⋮
│    class FakeFileResponse(FakeJSONResponse):
│        def __init__(self, path: pathlib.Path | str, media_type: str | None = None, filename: str |
⋮
│    class FakeResponse:
│        def __init__(self, content: object | None = None, status_code: int = 200):
│            self.body = content
│            self.status_code = status_code
⋮
│    class FakeStaticFiles:
│        def __init__(self, *_, **__):
⋮
│def _install_web_stubs() -> None:
│    try:
│        import importlib
│
│        importlib.import_module("app.web.common")
│        importlib.import_module("app.web.admin")
│        importlib.import_module("app.web.public")
│        importlib.import_module("app.web.client")
│        importlib.import_module("app.web.webhooks")
│        return
│    except Exception:
⋮
│    class FakeRouter:
│        def __init__(self):
│            self.routes = []
│            self.on_startup = []
│            self.on_shutdown = []
│            self.dependencies = []
⋮
│        def get(self, *_a, **_k):
⋮
│        def post(self, *_a, **_k):
⋮
│        def include_router(self, *_a, **_k):
⋮
│class _QueryParams:
│    def __init__(self, data: dict):
⋮
│    def get(self, key: str, default: str | None = None) -> str | None:
⋮
│class DummyRequest:
│    def __init__(
│        self,
│        body: dict,
│        base_url: str = "http://app:8000",
│        query: dict[str, str] | None = None,
│        headers: dict[str, str] | None = None,
⋮
│    async def json(self) -> dict:
⋮
│def test_webhook_returns_pdf_attachment(monkeypatch, tmp_path):
│    tenant = 9
⋮
│    class FakeQueue:
│        def __init__(self) -> None:
⋮
│def test_webhook_skips_pdf_after_first_send(monkeypatch, tmp_path):
│    tenant = 11
⋮
│    class FakeQueue:
│        def __init__(self) -> None:
│            self.pushed: list[tuple[str, dict]] = []
⋮
│@pytest.mark.anyio
│async def test_ask_llm_uses_planner(monkeypatch):
│    import core
⋮
│    class DummyChat:
│        def __init__(self):
⋮
│    class DummyOpenAI:
│        api_key: str | None = None
│
│        def __init__(self):
⋮

app/tests/test_public_wa_qr.py:
⋮
│class _DummyRedis:
│    def __init__(self, store: dict[str, str]):
⋮
│    def get(self, key: str):  # pragma: no cover - simple test helper
⋮
│    def set(self, key: str, value: str):  # pragma: no cover - simple test helper
⋮
│def test_wa_start_returns_state(monkeypatch):
│    _configure_retry(monkeypatch, attempts=1, delay=0.0)
⋮
│    class _Resp:
│        def __init__(self, code: int, data: dict):
│            self.status_code = code
⋮
│        def json(self):
⋮

app/tests/test_webhooks_provider.py:
⋮
│class _DummyAsyncRedis:
│    def __init__(self):
│        self.store: dict[str, str] = {}
⋮
│    async def set(self, key: str, value: str, **kwargs):  # pragma: no cover - helper
⋮

app/tests/test_whatsapp_send.py:
⋮
│class DummyResponse:
│    def __init__(
│        self,
│        status_code: int,
│        json_body: dict[str, Any] | None = None,
│        *,
│        text: str | None = None,
│        headers: dict[str, str] | None = None,
⋮
│    def json(self) -> dict[str, Any]:
⋮
│class StubTransportClient:
│    is_closed = False
│
│    def __init__(self, factory: Callable[[], DummyResponse]) -> None:
⋮
│    async def post(self, endpoint: str, json: dict[str, Any], timeout: Any) -> DummyResponse:
⋮

app/tests/test_worker_incoming.py:
⋮
│@pytest.mark.anyio
│async def test_worker_handles_whatsapp_event(monkeypatch: pytest.MonkeyPatch) -> None:
│    events: list[tuple[str, dict]] = []
│
│    class FakeRedis:
⋮

app/training/indexer.py:
⋮
│@dataclasses.dataclass
│class TrainingExample:
⋮

app/training/retriever.py:
⋮
│def ensure_training_index(tenant: int) -> Optional[TrainingIndex]:
⋮
│def retrieve_examples(tenant: int, query: str, k: int = 3) -> List[RetrievedExample]:
⋮
│def build_examples_block(tenant: int, query: str) -> str:
⋮

app/transport/__init__.py:
⋮
│class WhatsAppAddressError(ValueError):
⋮
│def normalize_e164_digits(value: str | int) -> str:
⋮
│def normalize_whatsapp_recipient(value: str | int) -> Tuple[str, str]:
⋮

app/web/client.py:
⋮
│build_pdf_index = catalog_index.build_pdf_index
│CatalogIndexError = catalog_index.CatalogIndexError
│index_to_catalog_items = getattr(catalog_index, "index_to_catalog_items", None)
⋮

app/web/common.py:
⋮
│def static_url(request: Any | None, path: str) -> str:
⋮
│def asset_version() -> str:
⋮

app/web/public.py:
⋮
│build_pdf_index = catalog_index.build_pdf_index
│index_to_catalog_items = catalog_index.index_to_catalog_items
│
⋮
│class TgWorkerCallError(RuntimeError):
│    """Raised when a call to the tgworker proxy fails."""
│
│    def __init__(self, url: str, detail: str) -> None:
⋮

config.py:
⋮
│@dataclass(frozen=True, slots=True)
│class TelegramConfig:
⋮
│@lru_cache(maxsize=1)
│def tg_worker_url() -> str:
⋮

core.py:
⋮
│get_tenant_pubkey = _app_core_mod.get_tenant_pubkey
⋮

create_project_snapshot.py:
⋮
│def parse_args() -> argparse.Namespace:
⋮

scripts/chat_simulator.py:
⋮
│def parse_args() -> SessionConfig:
⋮

scripts/waweb_manage.py:
⋮
│class TenantConfig:
│    def __init__(self, tenant_id: int, record: Optional[Dict[str, object]] = None):
│        self.id = tenant_id
│        record = record or {}
│        waweb_cfg = (
│            record.get("waweb") if isinstance(record.get("waweb"), dict) else {}
│        )
│        self.host = str(waweb_cfg.get("host") or f"waweb-{tenant_id}")
│        port_value = waweb_cfg.get("port")
│        try:
│            self.port = int(str(port_value).strip()) if port_value else None
⋮
│def parse_args() -> argparse.Namespace:
│    parser = argparse.ArgumentParser(description="Manage dedicated waweb containers")
⋮
│    def add_common(sub):
⋮

test.py:
⋮
│def call_brain(app_cid, ten, chan, text):
⋮

tgworker/api.py:
⋮
│if ConfigDict is None:
│
│    class _TenantModel(BaseModel):
│        class Config:
│            allow_population_by_field_name = True
│            allow_population_by_alias = True
│
│        @classmethod
│        def _ensure_tenant(cls, values: dict[str, Any]) -> dict[str, Any]:
│            if "tenant" not in values and "tenant_id" in values:
│                values = dict(values)
│                values["tenant"] = values.pop("tenant_id")
⋮
│else:  # pragma: no cover - executed only on pydantic v2
│
│    class _TenantModel(BaseModel):
│        model_config = ConfigDict(populate_by_name=True)
│
│        @classmethod
│        def _ensure_tenant(cls, values: dict[str, Any]) -> dict[str, Any]:
│            if isinstance(values, dict) and "tenant" not in values and "tenant_id" in values:
│                data = dict(values)
│                data["tenant"] = data.pop("tenant_id")
│                return data
│            return values
│
⋮
│def create_app() -> FastAPI:
│    cfg = telegram_config()
⋮
│    @app.post("/send")
│    async def send_message(
│        request: Request,
│        raw_payload: dict[str, Any] = Body(...),
│        _: None = Depends(require_credentials),
⋮

tgworker/manager.py:
⋮
│def session_file_path(tenant: int) -> Path:
⋮
│class QRNotFoundError(Exception):
⋮
│class QRExpiredError(Exception):
│    """Raised when a QR identifier has expired and should not be reused."""
│
│    def __init__(self, valid_until: Optional[float] = None) -> None:
⋮
│class NotAuthorizedError(RuntimeError):
⋮
│@dataclass(slots=True)
│class SessionState:
⋮
│@dataclass(slots=True)
│class TwoFASubmitResult:
⋮
│@dataclass(slots=True)
│class LoginFlowStateSnapshot:
⋮
│class TelegramSessionManager:
│    """Manage tenant-scoped TelegramClient instances and QR flows."""
│
│    def __init__(
│        self,
│        api_id: int,
│        api_hash: str,
│        sessions_dir: Path | None,
│        webhook_url: str,
│        *,
│        device_model: str,
│        system_version: str,
│        app_version: str,
⋮
│    async def wait_until_ready(self) -> None:
⋮
│    async def submit_password(self, tenant: int, password: str) -> TwoFASubmitResult:
⋮
│    async def send_message(
│        self,
│        tenant: int,
│        text: str | None = None,
│        peer_id: Any | None = None,
│        telegram_user_id: int | None = None,
│        username: str | None = None,
│        attachments: Optional[list[Dict[str, Any]]] = None,
│        reply_to: str | None = None,
⋮

tgworker/metrics.py:
⋮
│TG_QR_START_TOTAL = Counter(
│    "tg_qr_start_total", "Total number of QR login sessions initiated"
│)
│TG_QR_EXPIRED_TOTAL = Counter(
│    "tg_qr_expired_total",
│    "Total number of Telegram QR codes that expired before authorization",
│)
│TG_2FA_REQUIRED_TOTAL = Counter(
│    "tg_2fa_required_total", "Total number of login flows that required 2FA"
│)
│TG_LOGIN_SUCCESS_TOTAL = Counter(
│    "tg_login_success_total", "Total number of successful Telegram authorizations"
│)
│TG_LOGIN_FAIL_TOTAL = Counter(
│    "tg_login_fail_total",
│    "Total number of failed Telegram authorizations",
│    ["reason"],
⋮

tgworker/session_manager.py:
⋮
│@dataclass(slots=True)
│class SessionSnapshot:
⋮
│class SessionManager:
│    """Thin wrapper above ``TelegramSessionManager`` that exposes snapshots."""
│
│    def __init__(
│        self,
│        api_id: int,
│        api_hash: str,
│        webhook_url: str,
│        *,
│        sessions_dir: Path = SESSION_DIR,
│        device_model: str,
│        system_version: str,
│        app_version: str,
⋮
│    def stats_snapshot(self) -> dict[str, Any]:
⋮
│    async def submit_password(self, tenant_id: int, password: str) -> TwoFASubmitResult:
⋮
│    async def send_message(
│        self,
│        tenant: int,
│        *,
│        text: str | None = None,
│        peer_id: Any | None = None,
│        telegram_user_id: int | None = None,
│        username: str | None = None,
│        attachments: list[Dict[str, Any]] | None = None,
│        reply_to: str | None = None,
⋮

tgworker/tests/conftest.py:
⋮
│try:
│    import prometheus_client
│except ModuleNotFoundError:  # pragma: no cover - optional dependency
│    class _DummyRegistry:
│        def __init__(self) -> None:
│            self._names_to_collectors = {}
⋮

tgworker/tests/test_manager_self_peer.py:
⋮
│class _DummyTelethonClient(TelegramClient):
│    def __init__(self) -> None:  # pragma: no cover - super init bypassed
⋮

tgworker/tests/test_manager_submit_password.py:
⋮
│class _DummySession:
│    def __init__(self) -> None:
⋮
│class _FakeClient:
│    def __init__(self) -> None:
│        self._connected = True
│        self.sign_in_calls: list[tuple[tuple[object, ...], dict[str, object]]] = []
│        self.session = _DummySession()
⋮
│    def is_connected(self) -> bool:
⋮

tgworker/tests/test_pending_registry.py:
⋮
│class StubSessionManager:
│    def __init__(self, now: float) -> None:
│        self.now = now
│        self.stage = "idle"
│        self.qr_png = b"stub-png"
│        self.current_snapshot = SessionSnapshot(
│            tenant_id=0,
│            status="disconnected",
│            qr_id=None,
│            qr_valid_until=None,
│            twofa_pending=False,
⋮

tgworker/tests/test_send_api.py:
⋮
│@pytest.fixture
│def tgworker_app(monkeypatch: pytest.MonkeyPatch):
│    monkeypatch.setenv("TELEGRAM_API_ID", "1")
⋮
│    class DummyManager:
│        def __init__(self) -> None:
│            self.sent_payloads: list[dict[str, object]] = []
│            self.logout_calls: list[tuple[int, bool]] = []
│            self.self_peer: object = InputPeerSelf()
⋮
│        async def send_message(
│            self,
│            *,
│            tenant: int,
│            text: str | None = None,
│            peer_id: int | None = None,
│            telegram_user_id: int | None = None,
│            username: str | None = None,
│            attachments: list[dict[str, object]] | None = None,
│            reply_to: str | None = None,
⋮
│        def stats_snapshot(self) -> dict[str, int]:
⋮

tgworker/tests/test_twofa_submit.py:
⋮
│@pytest.fixture
│def tgworker_client(monkeypatch):
│    class DummyManager:
│        def __init__(self):
│            self.result: TwoFASubmitResult | None = None
│            self.snapshot = type(
│                "Snapshot",
│                (),
│                {
│                    "twofa_backoff_until": None,
│                    "to_payload": lambda self: {
│                        "status": "authorized",
│                        "qr_id": None,
⋮  

#### /ls  
> Repo files not in the chat:  
> .aider.chat.history.md  
> .autopush_probe  
> .autopush_test  
> .dockerignore  
> .env_recovery/containers.app.txt  
> .env_recovery/containers.postgres.txt  
> .env_recovery/containers.redis.txt  
> .env_recovery/containers.tgworker.txt  
> .env_recovery/containers.waweb.txt  
> .env_recovery/containers.worker.txt  
> .env_recovery/greps.local.txt  
> .env_recovery/pool.clean  
> .env_recovery/pool.kv  
> .env_recovery/required.vars.txt  
> .gitattributes  
> .github/workflows/ci.yml  
> .github/workflows/deploy.yml  
> .github/workflows/smoke.yml  
> .gitignore  
> .npm-global/package-lock.json  
> .npm-global/package.json  
> .touch  
> AGENTS.md  
> Caddyfile  
> Dockerfile  
> Makefile  
> README.md  
> app/__init__.py  
> app/agents/persona_default_ru.md  
> app/brain/__init__.py  
> app/brain/planner.py  
> app/brain/quality.py  
> app/catalog/__init__.py  
> app/catalog/indexer.py  
> app/catalog/io.py  
> app/catalog/pipeline.py  
> app/catalog/retriever.py  
> app/catalog_index.py  
> app/common.py  
> app/core/__init__.py  
> app/core/client.py  
> app/dao/__init__.py  
> app/dao/leads.py  
> app/db.py  
> app/export/__init__.py  
> app/export/whatsapp.py  
> app/fastapi_ext/__init__.py  
> app/fastapi_ext/responses.py  
> app/fastapi_ext/staticfiles.py  
> app/fastapi_ext/templating.py  
> app/fastapi_ext/testclient.py  
> app/httpx/__init__.py  
> app/integrations/__init__.py  
> app/integrations/avito.py  
> app/internal/__init__.py  
> app/internal/tenant.py  
> app/lib/transport_utils.py  
> app/main.py  
> app/metrics.py  
> app/models/__init__.py  
> app/models/lead.py  
> app/models/provider_token.py  
> app/onboarding_chat.py  
> app/outbox_worker.py  
> app/providers/__init__.py  
> app/providers/telegram_bot.py  
> app/repo/__init__.py  
> app/repo/provider_tokens.py  
> app/requirements.txt  
> app/schemas/__init__.py  
> app/schemas/transport.py  
> app/sklearn/__init__.py  
> app/sklearn/feature_extraction/__init__.py  
> app/sklearn/feature_extraction/text.py  
> app/sklearn/metrics/__init__.py  
> app/sklearn/metrics/pairwise.py  
> app/starlette_ext/__init__.py  
> app/starlette_ext/requests.py  
> app/starlette_ext/testclient.py  
> app/static/css/portal.css  
> app/static/js/admin-dashboard.js  
> app/static/js/boot.js  
> app/static/js/catalog-upload.js  
> app/static/js/client-settings.fallback.js  
> app/static/js/client-settings.js  
> app/static/js/connect-tg.js  
> app/static/js/public-connect.js  
> app/templates/admin/dashboard.html  
> app/templates/admin/login.html  
> app/templates/client/settings.html  
> app/templates/connect/avito.html  
> app/templates/connect/tg.html  
> app/templates/connect/wa.html  
> app/templates/layouts/base.html  
> app/tests/conftest.py  
> app/tests/test_admin_auth.py  
> app/tests/test_brain_planner.py  
> app/tests/test_brain_quality.py  
> app/tests/test_catalog_index_parser.py  
> app/tests/test_catalog_knowledge.py  
> app/tests/test_catalog_retriever.py  
> app/tests/test_client_catalog_upload.py  
> app/tests/test_client_settings.py  
> app/tests/test_core_paths.py  
> app/tests/test_csv_generation.py  
> app/tests/test_db_export_dialogs.py  
> app/tests/test_export_artifacts.py  
> app/tests/test_internal_tenant.py  
> app/tests/test_main_catalog.py  
> app/tests/test_main_webhook.py  
> app/tests/test_onboarding_preconditions.py  
> app/tests/test_public_catalog_csv.py  
> app/tests/test_public_key_guard.py  
> app/tests/test_public_settings.py  
> app/tests/test_public_tg.py  
> app/tests/test_public_wa_qr.py  
> app/tests/test_sales_engine.py  
> app/tests/test_static_assets.py  
> app/tests/test_tenant_waweb.py  
> app/tests/test_training_export_storage.py  
> app/tests/test_webhooks_provider.py  
> app/tests/test_whatsapp_export_safety.py  
> app/tests/test_whatsapp_send.py  
> app/tests/test_worker_incoming.py  
> app/tests/test_worker_whitelist.py  
> app/training/__init__.py  
> app/training/exporter.py  
> app/training/indexer.py  
> app/training/retriever.py  
> app/transport/__init__.py  
> app/transport/telegram.py  
> app/ui/design_tokens.json  
> app/web/__init__.py  
> app/web/admin.py  
> app/web/client.py  
> app/web/common.py  
> app/web/public.py  
> app/web/ui.py  
> app/web/webhooks.py  
> app/worker.py  
> clean  
> config.py  
> config/tenants.yml  
> core.py  
> create_project_snapshot.py  
> db/init/001_extensions.sql  
> db/init/002_schema.sql  
> db/init/003_contacts.sql  
> db/init/004_provider_tokens.sql  
> db/migrations/20240515_provider_tokens.sql  
> deploy.sh  
> diagnostics.json  
> docker-compose.ci.yml  
> docker-compose.override.yml  
> docker-compose.waweb.yml  
> docker-compose.yml  
> qr.png  
> scripts/chat_simulator.py  
> scripts/waweb_manage.py  
> snapshot_parts/project_snapshot_part_01.txt  
> snapshot_parts/project_snapshot_part_02.txt  
> snapshot_parts/project_snapshot_part_03.txt  
> snapshot_parts/project_snapshot_part_04.txt  
> snapshot_parts/project_snapshot_part_05.txt  
> snapshot_parts/project_snapshot_part_06.txt  
> snapshot_parts/project_snapshot_part_07.txt  
> snapshot_parts/project_snapshot_part_08.txt  
> snapshot_parts/project_snapshot_part_09.txt  
> snapshot_parts/project_snapshot_part_10.txt  
> test.py  
> tgworker/__init__.py  
> tgworker/__main__.py  
> tgworker/api.py  
> tgworker/main.py  
> tgworker/manager.py  
> tgworker/metrics.py  
> tgworker/session_manager.py  
> tgworker/tests/conftest.py  
> tgworker/tests/test_manager_self_peer.py  
> tgworker/tests/test_manager_submit_password.py  
> tgworker/tests/test_pending_registry.py  
> tgworker/tests/test_send_api.py  
> tgworker/tests/test_twofa_submit.py  
> tools/push-if-changed.sh  
> waweb/.npmrc  
> waweb/Dockerfile  
> waweb/index.js  
> waweb/package-lock.json  
> waweb/package.json  

#### /ask Общайся со мной всегда на РУССКОМ языке! Что ты можешь сказать о проекте - что он из себя представляет и какие функции выполняет?  

#### Общайся со мной всегда на РУССКОМ языке! Что ты можешь сказать о проекте - что он из себя представляет и какие функции выполняет?  

Based on the file summaries provided, the project appears to be a complex application with several components. Here are some key aspects:

1. **Communication and Messaging**: The project includes modules for handling communication through platforms like Telegram and WhatsApp. This is evident from files like `telegram_bot.py`, `transport.py`, and `tgworker` modules, which manage sending messages and handling sessions.

2. **AI and Planning**: The `planner.py` and `quality.py` files suggest the use of AI for generating sales replies and ensuring quality alignment with a generated plan. This indicates some level of automated response generation, likely using AI models.

3. **Catalog and Indexing**: There are components for managing catalogs and indexing, as seen in files like `catalog_index.py`, `indexer.py`, and `retriever.py`. These might be used for organizing and retrieving product or service information.

4. **Web and API**: The presence of `fastapi_ext` and `starlette_ext` modules suggests that the project includes a web API, likely built using FastAPI or Starlette. This would facilitate web-based interactions and integrations.

5. **Testing**: The `tests` directory indicates a comprehensive testing setup, ensuring the reliability and correctness of the application's functionality.

6. **Configuration and Management**: Files like `config.py` and `waweb_manage.py` suggest configuration management and possibly the management of web services or containers.

Overall, the project seems to be a sophisticated system for managing communication, possibly in a sales or customer service context, with AI-driven features and robust web API support.

> Tokens: 8.7k sent, 323 received. Cost: $0.02 message, $0.02 session.  
> app/brain/planner.py  
