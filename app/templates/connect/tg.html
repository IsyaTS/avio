{% extends "layouts/base.html" %}
{% set title = title or 'Подключение Telegram' %}
{% block content %}
<section class="surface stack" style="gap: 24px;">
    <div class="stack" style="gap: 8px;">
        <h1 class="section-title">Подключение Telegram</h1>
        <p class="section-subtitle">Сканируйте QR-код в приложении Telegram (Настройки → Устройства). После входа статус сменится на «Подключено».</p>
    </div>

    <div id="tg-status" class="status-text muted">Готовим QR-код…</div>

    <div class="surface surface--muted stack" style="gap: 12px; align-items: flex-start;">
        <img
            id="tg-qr-image"
            alt="QR-код Telegram"
            style="display:none; width: 260px; max-width: 100%; background:#fff; border-radius:12px; border:1px solid rgba(15,23,42,0.1); padding:12px; box-shadow:0 8px 24px rgba(15,23,42,0.1);"
        >
        <div id="tg-qr-placeholder" class="muted">QR генерируется…</div>
    </div>

    <button id="tg-qr-refresh" type="button" class="btn btn--secondary" style="align-self: flex-start;">Обновить QR</button>

    <div id="tg-2fa-block" class="surface stack" style="gap: 12px; max-width: 360px; display:none;">
        <form id="tg-2fa-form" class="stack" style="gap: 12px;" autocomplete="off">
            <label class="grid" style="grid-template-columns: 1fr; gap: 6px;">
                <span class="label">Пароль 2FA</span>
                <input id="tg-2fa-password" type="password" name="password" autocomplete="current-password" required>
            </label>
            <div class="stack" style="gap: 10px; align-items: flex-start;">
                <button id="tg-2fa-submit" type="submit" class="btn">Отправить</button>
                <div id="tg-2fa-error" class="status-text alert" style="display:none;"></div>
            </div>
        </form>
    </div>
    {% if persona_preview %}
    <!-- Persona preview: {{ persona_preview }} -->
    {% endif %}
</section>
{% endblock %}

{% set extra_scripts %}
<script>
window.__tgConnectConfig = {{ tg_connect_config | tojson }};
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const config = window.__tgConnectConfig || {};
    const tenant = String(config.tenant ?? '').trim();
    const key = String(config.key ?? '').trim();
    const urls = config.urls || {};

    const statusEl = document.getElementById('tg-status');
    const qrImage = document.getElementById('tg-qr-image');
    const qrPlaceholder = document.getElementById('tg-qr-placeholder');
    const refreshButton = document.getElementById('tg-qr-refresh');

    const twofaBlock = document.getElementById('tg-2fa-block');
    const twofaForm = document.getElementById('tg-2fa-form');
    const twofaPassword = document.getElementById('tg-2fa-password');
    const twofaSubmit = document.getElementById('tg-2fa-submit');
    const twofaError = document.getElementById('tg-2fa-error');

    if (!tenant || !key) {
        if (statusEl) {
            statusEl.textContent = 'Нет доступа: отсутствует ключ подключения.';
            statusEl.className = 'status-text alert';
        }
        if (refreshButton) {
            refreshButton.disabled = true;
        }
        return;
    }

    const baseParams = new URLSearchParams({ tenant, k: key });
    let pollTimer = null;
    let pollInFlight = false;
    let authorized = false;
    let currentQrId = '';

    function buildUrl(base, extra) {
        let target;
        try {
            target = new URL(base || '/', window.location.origin);
        } catch (error) {
            target = new URL('/', window.location.origin);
        }
        baseParams.forEach((value, name) => {
            if (value !== undefined && value !== null) {
                target.searchParams.set(name, value);
            }
        });
        if (extra) {
            Object.entries(extra).forEach(([name, value]) => {
                if (value === undefined || value === null || value === '') {
                    return;
                }
                target.searchParams.set(name, String(value));
            });
        }
        return target.toString();
    }

    function buildQrUrl(qrId) {
        const base = urls.tg_qr_png || '/pub/tg/qr.png';
        let target;
        try {
            target = new URL(base, window.location.origin);
        } catch (error) {
            target = new URL('/pub/tg/qr.png', window.location.origin);
        }
        target.searchParams.set('qr_id', qrId);
        target.searchParams.set('t', String(Date.now()));
        return target.toString();
    }

    function setStatus(text, variant = 'muted') {
        if (!statusEl) {
            return;
        }
        statusEl.textContent = text || '';
        statusEl.className = `status-text ${variant}`.trim();
    }

    function showPlaceholder(text) {
        if (qrPlaceholder) {
            qrPlaceholder.textContent = text || '';
            qrPlaceholder.style.display = '';
        }
        if (qrImage) {
            qrImage.style.display = 'none';
            qrImage.removeAttribute('src');
        }
    }

    function showQr(qrId) {
        if (!qrImage) {
            return;
        }
        const clean = String(qrId || '').trim();
        if (!clean) {
            currentQrId = '';
            showPlaceholder('QR генерируется…');
            return;
        }
        currentQrId = clean;
        qrImage.src = buildQrUrl(clean);
        qrImage.style.display = '';
        if (qrPlaceholder) {
            qrPlaceholder.style.display = 'none';
        }
    }

    function hideTwofa() {
        if (twofaBlock) {
            twofaBlock.style.display = 'none';
        }
        if (twofaError) {
            twofaError.textContent = '';
            twofaError.style.display = 'none';
        }
    }

    function showTwofa(message) {
        if (twofaBlock) {
            twofaBlock.style.display = '';
        }
        if (twofaError) {
            if (message) {
                twofaError.textContent = message;
                twofaError.style.display = '';
            } else {
                twofaError.textContent = '';
                twofaError.style.display = 'none';
            }
        }
        if (twofaPassword) {
            twofaPassword.focus();
        }
    }

    function stopPoll() {
        if (pollTimer) {
            window.clearTimeout(pollTimer);
            pollTimer = null;
        }
    }

    function schedulePoll(delay = 2500) {
        stopPoll();
        pollTimer = window.setTimeout(() => {
            pollStatus();
        }, delay);
    }

    function applyStatus(data) {
        const result = { continuePolling: true, delay: 2500 };
        const status = data && data.status ? String(data.status).toLowerCase() : '';
        const qrId = data && data.qr_id ? String(data.qr_id) : '';
        const lastError = data && data.last_error ? String(data.last_error) : '';
        const twofaPending = status === 'needs_2fa' || status === 'twofa_pending' || Boolean(data && data.twofa_pending);

        if (twofaPending) {
            showTwofa('');
            setStatus('Требуется пароль двухфакторной аутентификации.', 'alert');
            showPlaceholder('Введите пароль двухфакторной аутентификации в Telegram.');
            result.delay = 4000;
            authorized = false;
            return result;
        }

        hideTwofa();

        if (status === 'authorized') {
            authorized = true;
            setStatus('Подключено', 'success');
            showPlaceholder('Подключено');
            result.continuePolling = false;
            return result;
        }

        authorized = false;

        if (!status && !qrId) {
            showPlaceholder('QR генерируется…');
            setStatus('Ожидаем QR от Telegram…', 'muted');
            result.delay = 2500;
            return result;
        }

        if (status === 'waiting_qr' || (!status && qrId)) {
            if (qrId && qrId !== currentQrId) {
                showQr(qrId);
            } else if (!qrId) {
                currentQrId = '';
                showPlaceholder('QR генерируется…');
            }
            setStatus('Отсканируйте QR в Telegram → Settings → Devices.', 'muted');
            result.delay = 2500;
            return result;
        }

        if (status === 'qr_expired' || lastError === 'qr_login_timeout') {
            currentQrId = '';
            showPlaceholder('QR истёк. Нажмите «Обновить QR».');
            setStatus('QR истёк. Получите новый код.', 'alert');
            result.delay = 4000;
            return result;
        }

        if (status === 'disconnected') {
            currentQrId = '';
            showPlaceholder('Сессия отключена. Нажмите «Обновить QR».');
            setStatus('Сессия отключена.', 'alert');
            result.delay = 4000;
            return result;
        }

        if (qrId) {
            if (qrId !== currentQrId) {
                showQr(qrId);
            }
        } else {
            showPlaceholder('Ожидаем обновлений от Telegram…');
        }

        if (status) {
            setStatus(`Статус: ${status}`, 'muted');
        } else {
            setStatus('Статус неизвестен', 'muted');
        }
        result.delay = 4000;
        return result;
    }

    async function startSession(force = false) {
        stopPoll();
        currentQrId = force ? '' : currentQrId;
        showPlaceholder(force ? 'Готовим новый QR…' : 'Запрашиваем QR…');
        setStatus('Запрашиваем QR…', 'muted');
        const extra = { t: Date.now() };
        if (force) {
            extra.force = '1';
        }
        try {
            const response = await fetch(buildUrl(urls.tg_start || '/pub/tg/start', extra), {
                method: 'GET',
                cache: 'no-store',
            });
            if (!response.ok) {
                throw new Error(`start_failed_${response.status}`);
            }
            let payload = {};
            try {
                payload = await response.json();
            } catch (error) {
                payload = {};
            }
            if (payload && payload.qr_id) {
                showQr(payload.qr_id);
            }
            const outcome = applyStatus(payload || {});
            if (outcome.continuePolling) {
                schedulePoll(outcome.delay);
            } else {
                stopPoll();
            }
        } catch (error) {
            console.error('[tg-connect] start error', error);
            showPlaceholder('Не удалось запросить QR. Попробуйте позже.');
            setStatus('Не удалось запросить QR. Попробуйте позже.', 'alert');
            schedulePoll(5000);
        }
    }

    async function pollStatus() {
        if (pollInFlight) {
            return;
        }
        pollInFlight = true;
        try {
            const response = await fetch(buildUrl(urls.tg_status || '/pub/tg/status', { t: Date.now() }), {
                method: 'GET',
                cache: 'no-store',
            });
            if (!response.ok) {
                throw new Error(`status_failed_${response.status}`);
            }
            let payload = {};
            try {
                payload = await response.json();
            } catch (error) {
                payload = {};
            }
            const outcome = applyStatus(payload || {});
            if (outcome.continuePolling) {
                schedulePoll(outcome.delay);
            } else {
                stopPoll();
            }
        } catch (error) {
            console.error('[tg-connect] status error', error);
            if (!authorized) {
                setStatus('Сервис Telegram временно недоступен.', 'alert');
                showPlaceholder('Сервис Telegram временно недоступен.');
                schedulePoll(5000);
            }
        } finally {
            pollInFlight = false;
        }
    }

    if (refreshButton) {
        refreshButton.addEventListener('click', () => {
            startSession(true);
        });
    }

    if (qrImage) {
        qrImage.addEventListener('error', () => {
            if (!authorized) {
                currentQrId = '';
                showPlaceholder('Не удалось загрузить QR. Нажмите «Обновить QR».');
            }
        });
    }

    if (twofaForm) {
        twofaForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            if (!twofaPassword) {
                return;
            }
            const password = twofaPassword.value.trim();
            if (!password) {
                showTwofa('Введите пароль.');
                return;
            }
            if (twofaSubmit) {
                twofaSubmit.disabled = true;
            }
            try {
                const response = await fetch(buildUrl(urls.tg_password || '/pub/tg/password', { t: Date.now() }), {
                    method: 'POST',
                    cache: 'no-store',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password }),
                });
                if (!response.ok) {
                    let message = 'Не удалось отправить пароль.';
                    try {
                        const errorBody = await response.json();
                        if (errorBody && typeof errorBody === 'object') {
                            if (errorBody.error) {
                                message = String(errorBody.error);
                            } else if (errorBody.detail) {
                                message = String(errorBody.detail);
                            }
                        }
                    } catch (jsonError) {
                        // ignore json parsing errors
                    }
                    showTwofa(message);
                    schedulePoll(5000);
                } else {
                    showTwofa('');
                    twofaPassword.value = '';
                    setStatus('Пароль отправлен. Проверяем статус…', 'muted');
                    pollStatus();
                }
            } catch (error) {
                console.error('[tg-connect] password error', error);
                showTwofa('Не удалось отправить пароль. Попробуйте ещё раз.');
            } finally {
                if (twofaSubmit) {
                    twofaSubmit.disabled = false;
                }
            }
        });
    }

    startSession(false);
});
</script>
{% endset %}
