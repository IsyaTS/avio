{% extends "layouts/base.html" %}
{% set title = title or 'Подключение Telegram' %}
{% block content %}
<section class="surface stack" style="gap: 20px;">
    <div class="stack" style="gap: 8px;">
        <h1 class="section-title">Подключение Telegram</h1>
        <p class="section-subtitle">Сканируйте QR-код в приложении Telegram (Настройки → Устройства). После входа статус сменится на «Подключено».</p>
    </div>

    <div class="stack" style="gap: 10px; align-items: flex-start;">
        <button id="tg-connect-start" type="button" class="btn">Подключить Telegram</button>
        <div id="tg-status-message" class="status-text muted"></div>
        <div id="tg-connected-label" class="status-text success" style="display:none;">Подключено</div>
        <div id="tg-error-message" class="status-text alert" style="display:none;"></div>
    </div>

    <div id="tg-qr-block" class="surface surface--muted stack" style="gap: 12px; align-items: flex-start; display:none;">
        <img id="tg-qr-image" alt="QR-код Telegram" style="display:none; width: 260px; max-width: 100%; background:#fff; border-radius:12px; border:1px solid rgba(15,23,42,0.1); padding:12px; box-shadow:0 8px 24px rgba(15,23,42,0.1);">
        <div id="tg-qr-placeholder" class="muted">QR генерируется…</div>
        <button id="tg-qr-refresh" type="button" class="btn btn--secondary" style="display:none;">Обновить QR</button>
    </div>

    <div id="tg-2fa-block" class="surface stack" style="gap: 12px; max-width: 360px; display:none;">
        <form id="tg-2fa-form" class="stack" style="gap: 12px;" autocomplete="off">
            <label class="grid" style="grid-template-columns: 1fr; gap: 6px;">
                <span class="label">Пароль 2FA</span>
                <input id="tg-2fa-password" type="password" name="password" autocomplete="current-password" required>
            </label>
            <div class="stack" style="gap: 10px; align-items: flex-start;">
                <button id="tg-2fa-submit" type="submit" class="btn">Отправить</button>
                <div id="tg-2fa-error" class="status-text alert" style="display:none;"></div>
            </div>
        </form>
    </div>

    <div class="surface surface--muted">
        <ul class="muted" style="margin: 0; padding-left: 18px; line-height: 1.6;">
            <li>Статус «waiting_qr» означает, что нужно сканировать QR в приложении Telegram.</li>
            <li>Статусы «needs_2fa» или «twofa_pending» показывают ожидание пароля — форма появится автоматически.</li>
            <li>Если QR или пароль истекли, нажмите «Обновить QR» и повторите подключение.</li>
        </ul>
    </div>
    {% if persona_preview %}
    <!-- Persona preview: {{ persona_preview }} -->
    {% endif %}
</section>
{% endblock %}

{% set extra_scripts %}
<script>
window.__tgConnectConfig = {{ tg_connect_config | tojson }};
</script>
<script>
(function () {
    const config = window.__tgConnectConfig || {};
    const tenant = config.tenant;
    const key = config.key;
    const urls = config.urls || {};

    const startButton = document.getElementById('tg-connect-start');
    const statusMessage = document.getElementById('tg-status-message');
    const connectedLabel = document.getElementById('tg-connected-label');
    const errorMessage = document.getElementById('tg-error-message');

    const qrBlock = document.getElementById('tg-qr-block');
    const qrImage = document.getElementById('tg-qr-image');
    const qrPlaceholder = document.getElementById('tg-qr-placeholder');
    const qrRefreshButton = document.getElementById('tg-qr-refresh');

    const twofaBlock = document.getElementById('tg-2fa-block');
    const twofaForm = document.getElementById('tg-2fa-form');
    const twofaPassword = document.getElementById('tg-2fa-password');
    const twofaSubmit = document.getElementById('tg-2fa-submit');
    const twofaError = document.getElementById('tg-2fa-error');

    if (!tenant || !key) {
        if (statusMessage) {
            statusMessage.textContent = 'Нет доступа: отсутствует ключ подключения.';
            statusMessage.className = 'status-text alert';
        }
        return;
    }

    const baseParams = { tenant: String(tenant), k: String(key) };
    const pollInterval = 2500;
    let pollTimer = null;
    let pollActive = false;
    let pollInFlight = false;
    let lastQrId = '';

    function buildUrl(base, extra) {
        const target = new URL(base || '/', window.location.origin);
        Object.entries(baseParams).forEach(([name, value]) => {
            if (value !== undefined && value !== null && value !== '') {
                target.searchParams.set(name, value);
            }
        });
        if (extra) {
            Object.entries(extra).forEach(([name, value]) => {
                if (value === undefined || value === null || value === '') {
                    return;
                }
                target.searchParams.set(name, String(value));
            });
        }
        return target.toString();
    }

    function buildQrUrl(qrId) {
        const target = new URL(urls.tg_qr_png || '/pub/tg/qr.png', window.location.origin);
        target.searchParams.set('qr_id', qrId);
        target.searchParams.set('t', String(Date.now()));
        return target.toString();
    }

    function show(element) {
        if (element) {
            element.style.display = '';
        }
    }

    function hide(element) {
        if (element) {
            element.style.display = 'none';
        }
    }

    function setStatus(text, variant = 'muted') {
        if (!statusMessage) {
            return;
        }
        statusMessage.textContent = text || '';
        statusMessage.className = `status-text ${variant}`.trim();
    }

    function setError(text) {
        if (!errorMessage) {
            return;
        }
        if (text) {
            errorMessage.textContent = text;
            show(errorMessage);
        } else {
            errorMessage.textContent = '';
            hide(errorMessage);
        }
    }

    function updateQr(qrId) {
        if (!qrImage || !qrPlaceholder) {
            return;
        }
        const clean = (qrId || '').toString().trim();
        if (!clean) {
            hide(qrImage);
            qrImage.removeAttribute('src');
            qrPlaceholder.textContent = 'QR генерируется…';
            show(qrPlaceholder);
            lastQrId = '';
            return;
        }
        lastQrId = clean;
        qrImage.src = buildQrUrl(clean);
        show(qrImage);
        hide(qrPlaceholder);
    }

    function showTwofaBlock() {
        hide(qrBlock);
        show(twofaBlock);
        hide(twofaError);
        if (twofaPassword) {
            twofaPassword.focus();
        }
    }

    function showConnected() {
        setStatus('Подключено', 'success');
        show(connectedLabel);
        hide(qrBlock);
        hide(twofaBlock);
        hide(qrRefreshButton);
        setError('');
        stopPolling();
    }

    function resetUi() {
        hide(connectedLabel);
        setError('');
    }

    function stopPolling() {
        pollActive = false;
        if (pollTimer) {
            window.clearTimeout(pollTimer);
            pollTimer = null;
        }
    }

    function schedulePoll(delay) {
        if (!pollActive) {
            return;
        }
        const jitter = Math.floor(Math.random() * 400);
        const timeout = Math.max(2000, (delay || pollInterval) + jitter);
        pollTimer = window.setTimeout(fetchStatus, timeout);
    }

    async function fetchStatus() {
        if (pollInFlight || !pollActive) {
            return;
        }
        pollInFlight = true;
        const url = buildUrl(urls.tg_status || '/pub/tg/status');
        try {
            const response = await fetch(url, { cache: 'no-store' });
            if (!response.ok) {
                throw new Error(`status_${response.status}`);
            }
            const data = await response.json();
            applyStatus(data || {});
        } catch (error) {
            setError('Не удалось обновить статус. Попробуйте позже.');
        } finally {
            pollInFlight = false;
            schedulePoll(pollInterval);
        }
    }

    function applyStatus(payload) {
        resetUi();
        const status = (payload && payload.status) || '';
        if (status) {
            setStatus(`Статус: ${status}`);
        } else {
            setStatus('Статус недоступен', 'alert');
        }

        if (payload && (payload.last_error || payload.error)) {
            if (status === 'disconnected' && ['qr_login_timeout', 'twofa_timeout'].includes(payload.last_error)) {
                show(qrRefreshButton);
            } else {
                setError(String(payload.last_error || payload.error));
                hide(qrRefreshButton);
            }
        } else {
            hide(qrRefreshButton);
        }

        if (status === 'authorized') {
            showConnected();
            return;
        }

        if (status === 'waiting_qr') {
            updateQr(payload.qr_id || '');
            show(qrBlock);
            hide(twofaBlock);
            return;
        }

        const pendingTwofa = Boolean(payload && payload.twofa_pending);

        if (status === 'needs_2fa' || pendingTwofa) {
            showTwofaBlock();
            return;
        }

        if (payload && payload.qr_id) {
            updateQr(payload.qr_id);
            show(qrBlock);
        } else {
            hide(qrBlock);
        }
    }

    async function startSession(force) {
        setError('');
        setStatus('Отправляем запрос на подключение…');
        const extra = force ? { force: '1' } : undefined;
        const url = buildUrl(urls.tg_start || '/pub/tg/start', extra);
        pollActive = true;
        try {
            await fetch(url, { method: 'GET', cache: 'no-store' });
        } catch (error) {
            setStatus('Не удалось отправить запрос к Telegram.', 'alert');
        } finally {
            fetchStatus();
        }
    }

    function handleTwofaError(message) {
        if (!twofaError) {
            return;
        }
        if (message) {
            twofaError.textContent = message;
            show(twofaError);
        } else {
            twofaError.textContent = '';
            hide(twofaError);
        }
    }

    async function submitTwofa(password) {
        const url = buildUrl(urls.tg_password || '/pub/tg/password');
        try {
            if (twofaSubmit) {
                twofaSubmit.disabled = true;
            }
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ password }),
            });
            if (response.status === 200) {
                handleTwofaError('');
                pollActive = true;
                fetchStatus();
                return;
            }
            let detail = '';
            try {
                const payload = await response.json();
                detail = payload && (payload.detail || payload.error) || '';
            } catch (parseError) {
                detail = '';
            }
            if (response.status === 400 && detail === 'invalid_password') {
                handleTwofaError('Неверный пароль. Попробуйте ещё раз.');
            } else {
                handleTwofaError('Ошибка подтверждения. Попробуйте позже.');
            }
        } catch (error) {
            handleTwofaError('Не удалось отправить пароль.');
        } finally {
            if (twofaSubmit) {
                twofaSubmit.disabled = false;
            }
        }
    }

    if (startButton) {
        startButton.addEventListener('click', function () {
            startSession(false);
        });
    }

    if (qrRefreshButton) {
        qrRefreshButton.addEventListener('click', function () {
            startSession(true);
        });
    }

    if (twofaForm) {
        twofaForm.addEventListener('submit', function (event) {
            event.preventDefault();
            const password = (twofaPassword && twofaPassword.value) ? twofaPassword.value.trim() : '';
            if (!password) {
                handleTwofaError('Введите пароль от Telegram.');
                if (twofaPassword) {
                    twofaPassword.focus();
                }
                return;
            }
            handleTwofaError('');
            submitTwofa(password);
        });
    }

    pollActive = true;
    fetchStatus();
})();
</script>
{% endset %}
